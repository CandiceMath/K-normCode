[![INFORMS Journal on Computing Logo](https://INFORMSJoC.github.io/logos/INFORMS_Journal_on_Computing_Header.jpg)](https://pubsonline.informs.org/journal/ijoc)

# Convex and Nonconvex Risk-based Linear Regression at Scale

This archive is distributed in association with the [INFORMS Journal on
Computing](https://pubsonline.informs.org/journal/ijoc) under the [General Public License v2.0](LICENSE).

The software in this repository is a snapshot of the software that was used in the research reported 
on in the paper [Convex and Nonconvex Risk-based Linear Regression at Scale](tbd) by Can Wu, Ying Cui, Donghui Li and Defeng Sun.
The snapshot corresponds to [this release](https://github.com/Wu-Can/k-normCode) in the development repository. 

## Cite

To cite this material, please cite this repository, using the following DOI.

[![DOI](tbd)](tbd)

Below is the BibTex for citing this version of the code.

```
@article{Risk202Xregression,
  author =        {Can Wu, Ying Cui, Donghui Li and Defeng Sun},
  publisher =     {INFORMS Journal on Computing},
  title =         {Convex and Nonconvex Risk-based Linear Regression at Scale},
  year =          {202X},
  doi =           {TBD},
  url =          {https://github.com/INFORMSJoC/2022.0012},
}  
```

## Description

The goal of this software is to solve high-dimensional sparse linear regression problems 
under either the VaR or the CVaR risk measures. Please see the paper for details.

The software is written in MATLAB and compares with the publically available [Gurobi optimizer](https://www.gurobi.com/downloads/gurobi-software/), and the [PSG program](http://www.aorda.com/index.php/downloading/).  For all of them,
free academic licenses are available.

This software contains three kinds of optimization problems and the corresponding solvers:
- CVaR regression with a fixed lambda: the convex CVaR-based sparse linear regression with a fixed value of lambda.
  - **N-ALM**: the semismooth Newton based on the proximal augmented Lagrangian method
  - **ADMM**: the alternating direction method of multipliers 
  - **Gurobi**: the barrier method in Gurobi
  - **S-IRPN**: the smoothing method based on the inexact regularized proximal Newton method 
  - **PSG solvers**: seven solvers incuding **VAN**, **TANK**, **CAR**, **BULDOZER**, **VANGRB**, **CARGRB** and **HELI** in the PSG package  
- CVaR regression with a sequence of lambda: the convex CVaR-based sparse linear regression with a given sequence of grid points lambda.
  - **AS+N-ALM**: the adaptive sieving strategy combined with **N-ALM**
  - **Warm+N-ALM**: the warm-strated **N-ALM**
  - **N-ALM**: the pure **N-ALM** 
- Truncated CVaR regression: the nonconvex truncated CVaR-based sparse linear regression.
  - **MM+N-PPA**: the majorization-minimization algorithm combined with the semismooth Newton method based on the proximal point algorithm
  - **MM+Gurobi**: the majorization-minimization algorithm combined with the barrier method in Gurobi

Two kinds of data sets are used in this software:
- UCI data: 
- Random data: 

This software contains nine folders:
- `Test1_fixed_lambda`: test the performance of **N-ALM**, **ADMM**, **Gurobi**, **S-IRPN** and **PSG solvers** for CVaR regression with a fixed lambda.
- `Test2_Solution_path`: test the performance of **AS+N-ALM**, **Warm+N-ALM** and **N-ALM** for CVaR regression with a sequence of lambda.
- `Test3_truncated_CVaR_MM`: test the performance of **MM+N-PPA** and **MM+Gurobi** for truncated CVaR regression.
- `Test4_Risk-averse_model`: test the performance of the risk-sensitive and risk-neutral regression models.
- `genUCIdatafun`: convert the UCI data from LIBSVM format to MAT format.
- `mainfun`: all main functions for the above solvers.
- `mexfun`: two funtions in MEX format.
- `solver`: all the subfunctions called by the above main functions.
- `UCIdata`: all availiable data for the UCI data and the high-accurate objective values.


## Usage

The results in the paper were generated by this software that had been carried out using MATLAB R2020b on a desktop computer (16-core, Intel(R) Core(TM) i7-10700 @ 2.90GHz, 32G RAM).

Step 1. Unpack the software and run Matlab in its directory.

Step 2. In the Matlab command window, type:

```
    >> startup 
```

Step 3. Generate the UCI dataset as follows:

-  Download the original datasets tested in the paper from [UCI data repository](
https://archive.ics.uci.edu/ml/index.php) or in its [LIBSVM
    format](https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/regression.html);   
- Put them into the folder [\genUCIdatafun\UCIdataorg];
- Run genUCIdata.m (For demonstration purpose, "mpg_scale.txt" and "housing_scale.txt" are left in the folder
    [\genUCIdatafun\UCIdataorg]).
    
    
    

Correspondence between the results in the paper and the scripts in the software

<table>
	<tr>
		<th> Results</th>
		<th> Folders or Path</th>
		<th> Scripts</th>
		<th> INPUT in Scripts</th>
	</tr>
	<tr>
		<td rowspan="3">Table 2</td>
		<td rowspan="3">'Test1_fixed_lambda'</td>
		<td>Test_NALM_UCI</td>
		<td>prob=[1:11], flag_tol=1, tol=1e-3, alpha_vec=[0.9, 0.5, 0.1]</td>
	</tr>
	<tr>
		<td>Test_SIRPN_UCI</td>
		<td>prob=[1:11]</td>
	</tr>
	<tr>
		<td>Test_ADMM_UCI</td>
		<td>prob=[1:11], flag_tol=1</td>
	</tr>
	<tr>
		<td rowspan="2">Table 3</td>
		<td rowspan="2">'Test1_fixed_lambda'</td>
		<td>Test_NALM_UCI</td>
		<td>prob=[7:9], flag_tol=0, tol=1e-6</td>
	</tr>
	<tr>
	        <td>Test_PSG_UCI</td>
		<td>prob=[7:9], SOLVER='VAN'</td>
	</tr>
	<tr>
		<td rowspan="2">Table 4</td>
		<td rowspan="2">'Test1_fixed_lambda'</td>
		<td>Test_NALM_UCI</td>
		<td>prob=[1:11], flag_tol=0, tol=1e-8</td>
	</tr>
	<tr>
	        <td>Test_Barrier_Gurobi_UCI</td>
		<td>prob=[1:11]</td>
	</tr>
	<tr>
		<td rowspan="3">Table 5</td>
		<td rowspan="3">'Test2_Solution_path'</td>
		<td>Test_AS_NALM_path_UCI</td>
		<td>Prob = [9, 4, 2]</td>
	</tr>
	<tr>
		<td>Test_warm_NALM_path_UCI</td>
		<td>Prob = [9, 4, 2]</td>
	</tr>
	<tr>
		<td>Test_NALM_path_UCI</td>
		<td>Prob = [9, 4, 2]</td>
	</tr>
	<tr>
		<td>Figures 1 & 2</td>
		<td>'Test2_Solution_path/ Result_solution_path_figure_UCI'</td>
		<td>Test_path_figure_UCI</td>
		<td>flag_time=1, flag_nnz=1 </td>
	</tr>
	<tr>
		<td rowspan="2">Table 6</td>
		<td rowspan="2">'Test3_truncated_CVaR_MM'</td>
		<td>Test_MM_NPPA_UCI</td>
		<td>prob = [10 11 5 8 9]</td>
	</tr>
	<tr>
	        <td>Test_MM_Gurobi_UCI</td>
		<td>prob = [10 11 5 8 9]</td>
</table>

Correspondence between the results in the supplementary materials and the scripts in the software

<table>
	<tr>
		<th> Results</th>
		<th> Folders</th>
		<th> Scripts</th>
		<th> INPUT in Scripts</th>
	</tr>
	<tr>
		<td>Table 2</td>
		<td>'Test4_Risk-averse_model'</td>
		<td>Test_convex_CVaR_model_random</td>
		<td>flag_err=1 or 2 or 3</td>
	</tr>
	<tr>
		<td>Table 4</td>
		<td>'Test4_Risk-averse_model'</td>
		<td>Test_truncated_CVaR_model_random</td>
		<td>conf=1</td>
	</tr>
	<tr>
		<td>Table 5</td>
		<td>'Test4_Risk-averse_model'</td>
		<td>Test_truncated_CVaR_model_random</td>
		<td>conf=2</td>
	<tr>
		<td rowspan="3">Table 6</td>
		<td rowspan="3">'Test1_fixed_lambda'</td>
		<td>Test_NALM_random</td>
		<td>prob=[5:7], flag_tol=1, tol=1e-3, alpha_vec=[0.9;0.5;0.1]</td>
	</tr>
	<tr>
		<td>Test_SIRPN_random</td>
		<td>prob=[5:7]</td>
	</tr>
	<tr>
		<td>Test_ADMM_random</td>
		<td>prob=[5:7], flag_tol=1</td>
	</tr>
	<tr>
		<td rowspan="2">Table 7</td>
		<td rowspan="2">'Test1_fixed_lambda'</td>
		<td>Test_NALM_random</td>
		<td>prob=[1 2], flag_tol=0, tol=1e-6</td>
	</tr>
	<tr>
	        <td>Test_PSG_random</td>
		<td>prob=[1 2], SOLVER=all seven solvers</td>
	</tr>
	<tr>
		<td rowspan="2">Table 8</td>
		<td rowspan="2">'Test1_fixed_lambda'</td>
		<td>Test_NALM_random</td>
		<td>prob=[3 4], flag_tol=0, tol=1e-6</td>
	</tr>
	<tr>
	        <td>Test_PSG_random</td>
		<td>prob=[3 4], SOLVER='VAN'</td>
	</tr>
	<tr>
		<td rowspan="2">Table 9</td>
		<td rowspan="2">'Test1_fixed_lambda'</td>
		<td>Test_NALM_random</td>
		<td>prob=[5:7], flag_tol=0, tol=1e-8</td>
	</tr>
	<tr>
	        <td>Test_Barrier_Gurobi_random</td>
		<td>m_vec=[3e2, 1e3, 3e3], n=[5e4, 1e5, 5e5]</td>
	</tr>
	<tr>
		<td>Table 10</td>
		<td>'Test1_fixed_lambda'</td>
		<td>Test_NALM_UCI</td>
		<td>prob=6, flag_tol=0, tol=1e-6, alpha_vec=1-[1e-3.*[1 5], 1e-2.*[1:2:9, 10:10:90]</td>
	</tr>
	<tr>
		<td>Table 11</td>
		<td>'Test1_fixed_lambda'</td>
		<td>Test_NALM_random</td>
		<td>prob=7, flag_tol=0, tol=1e-6, alpha_vec=1-[1e-3.*[1 5], 1e-2.*[1:2:9, 10:10:90]]</td>
	</tr>
	<tr>
		<td rowspan="3">Table 12</td>
		<td rowspan="3">'Test2_Solution_path'</td>
		<td>Test_AS_NALM_path_random</td>
		<td rowspan="3">m_vec=1e3.*[0.5, 1, 3], n_vec=1e5.*[1, 2, 5], edgp_mat=[15 30 45;15 30 45;30 60 90]</td>
	</tr>
	<tr>
		<td>Test_warm_NALM_path_random</td>
	</tr>
	<tr>
		<td>Test_NALM_path_random</td>
	</tr>
	<tr>
		<td>Figures 2 & 3</td>
		<td>'Test2_Solution_path/ Result_solution_path_figure_random'</td>
		<td>Test_path_figure_random</td>
		<td>flag_time=1, flag_nnz=1</td>
	</tr>
	<tr>
		<td rowspan="2">Table 13</td>
		<td rowspan="2">'Test3_truncated_CVaR_MM'</td>
		<td>Test_MM_NPPA_random</td>
		<td rowspan="2">m_vec=1e3.*[0.5, 0.5, 1, 1.5, 3], lamc_vec=[0.15 0.1 0.05], n_vec=1e5.*[0.03, 0.5 5, 1, 2, 5]</td>
	</tr>
	<tr>
	        <td>Test_MM_Gurobi_random</td>
	
</table>










## Replicating

- To replicate the results in Tables 2-4, run scripts in the folder `Test1_fixed_lambda`, respectively.
- To replicate the results in Figures 1-2 and Tables 5, run scripts in the folder `Test2_Solution_path`, respectively.
- To replicate the results in Table 6, run scripts in the folder `Test3_truncated_CVaR_MM`, respectively.   



